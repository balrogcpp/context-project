diff --git a/CMake/Templates/imconfig.h b/CMake/Templates/imconfig.h
index 7f6a28c..8610098 100644
--- a/CMake/Templates/imconfig.h
+++ b/CMake/Templates/imconfig.h
@@ -1,5 +1,6 @@
 #pragma once
 #define IMGUI_DISABLE_OBSOLETE_FUNCTIONS
+#define IMGUI_USE_WCHAR32
 #include <OgreOverlayPrerequisites.h>
 #define IMGUI_API _OgreOverlayExport
 #cmakedefine IMGUI_ENABLE_FREETYPE
\ No newline at end of file
diff --git a/CMakeLists.txt b/CMakeLists.txt
index ade278e..d97e599 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -14,7 +14,7 @@
 # and provide build configuration options.
 ######################################################################
 
-cmake_minimum_required(VERSION 3.13.0)
+cmake_minimum_required(VERSION 3.15.0)
 
 set(CMAKE_CXX_STANDARD 14)
 set(CMAKE_CXX_STANDARD_REQUIRED ON)
@@ -330,7 +330,7 @@ option(OGRE_BUILD_COMPONENT_RTSHADERSYSTEM "Build RTShader System component" TRU
 cmake_dependent_option(OGRE_BUILD_RTSHADERSYSTEM_SHADERS "Build RTShader System FFP shaders" TRUE "OGRE_BUILD_COMPONENT_RTSHADERSYSTEM" FALSE)
 
 cmake_dependent_option(OGRE_BUILD_SAMPLES "Build Ogre demos" TRUE "OGRE_BUILD_COMPONENT_OVERLAY;OGRE_BUILD_COMPONENT_BITES" FALSE)
-cmake_dependent_option(OGRE_BUILD_TOOLS "Build the command-line tools" TRUE "pugixml_FOUND;NOT APPLE_IOS;NOT WINDOWS_STORE;NOT WINDOWS_PHONE" FALSE)
+cmake_dependent_option(OGRE_BUILD_TOOLS "Build the command-line tools" TRUE "NOT CMAKE_CROSSCOMPILING;pugixml_FOUND;NOT APPLE_IOS;NOT WINDOWS_STORE;NOT WINDOWS_PHONE" FALSE)
 cmake_dependent_option(OGRE_BUILD_XSIEXPORTER "Build the Softimage exporter" FALSE "Softimage_FOUND" FALSE)
 cmake_dependent_option(OGRE_BUILD_LIBS_AS_FRAMEWORKS "Build frameworks for libraries on OS X." TRUE "APPLE;NOT OGRE_BUILD_PLATFORM_APPLE_IOS" FALSE)
 cmake_dependent_option(OGRE_BUILD_TESTS "Build the unit tests & PlayPen" FALSE "OGRE_BUILD_COMPONENT_BITES" FALSE)
@@ -373,7 +373,7 @@ cmake_dependent_option(OGRE_INSTALL_SAMPLES "Install Ogre demos." TRUE "OGRE_BUI
 option(OGRE_INSTALL_TOOLS "Install Ogre tools." TRUE)
 option(OGRE_INSTALL_DOCS "Install documentation." TRUE)
 cmake_dependent_option(OGRE_INSTALL_PDB "Install debug pdb files" TRUE "MSVC" FALSE)
-option(OGRE_PROFILING "Enable internal instrumentation." FALSE)
+cmake_dependent_option(OGRE_PROFILING "Enable internal instrumentation." TRUE "${CMAKE_BUILD_TYPE} MATCHES Debug OR ${CMAKE_BUILD_TYPE} MATCHES RelWithDebInfo" FALSE)
 set(OGRE_PROFILING_REMOTERY_PATH "" CACHE PATH "set this to Remotery/lib to use Remotery instead of the buildin profiler")
 cmake_dependent_option(OGRE_CONFIG_STATIC_LINK_CRT "Statically link the MS CRT dlls (msvcrt)" FALSE "MSVC" FALSE)
 set(OGRE_LIB_DIRECTORY "lib${LIB_SUFFIX}" CACHE STRING "Install path for libraries, e.g. 'lib64' on some 64-bit Linux distros.")
diff --git a/Components/Overlay/CMakeLists.txt b/Components/Overlay/CMakeLists.txt
index 41bd634..a419aa2 100644
--- a/Components/Overlay/CMakeLists.txt
+++ b/Components/Overlay/CMakeLists.txt
@@ -92,7 +92,7 @@ if(OGRE_BUILD_COMPONENT_OVERLAY_IMGUI)
   configure_file(${OGRE_TEMPLATES_DIR}/imconfig.h ${IMGUI_DIR}/imconfig.h)
 
   list(APPEND HEADER_FILES
-    ${IMGUI_DIR}/imgui.h
+    ${IMGUI_DIR}/imgui.h ${IMGUI_DIR}/imgui_internal.h ${IMGUI_DIR}/imstb_textedit.h ${IMGUI_DIR}/imstb_truetype.h ${IMGUI_DIR}/imstb_rectpack.h
     ${IMGUI_DIR}/imconfig.h)
 endif()
 
diff --git a/Components/Overlay/src/OgreOverlayProfileSessionListener.cpp b/Components/Overlay/src/OgreOverlayProfileSessionListener.cpp
index 81b94a4..9e2e070 100644
--- a/Components/Overlay/src/OgreOverlayProfileSessionListener.cpp
+++ b/Components/Overlay/src/OgreOverlayProfileSessionListener.cpp
@@ -108,7 +108,7 @@ namespace Ogre
     void OverlayProfileSessionListener::finializeSession()
     {
         OverlayContainer* container = dynamic_cast<OverlayContainer*>(mProfileGui);
-        if (container)
+        if (false)
         {
             while (!container->getChildren().empty())
             {
@@ -121,7 +121,7 @@ namespace Ogre
             OverlayManager::getSingleton().destroyOverlayElement(mProfileGui);
         if(mOverlay)
             OverlayManager::getSingleton().destroy(mOverlay);
-
+        OverlayManager::getSingleton().destroyAllOverlayElements();
         mProfileBars.clear();
     }
     //-----------------------------------------------------------------------
diff --git a/Components/Terrain/src/OgreTerrainQuadTreeNode.cpp b/Components/Terrain/src/OgreTerrainQuadTreeNode.cpp
index 458419b..d0eb34e 100644
--- a/Components/Terrain/src/OgreTerrainQuadTreeNode.cpp
+++ b/Components/Terrain/src/OgreTerrainQuadTreeNode.cpp
@@ -178,7 +178,7 @@ namespace Ogre
             for (int i = 0; i < 4; ++i)
                 mChildren[i]->prepare();
         }
-
+        setCastShadows(TerrainGlobalOptions::getSingleton().getCastsDynamicShadows());
     }
     //---------------------------------------------------------------------
     void TerrainQuadTreeNode::prepare(StreamSerialiser& stream)
diff --git a/OgreMain/CMakeLists.txt b/OgreMain/CMakeLists.txt
index 483f9f3..0b87d5d 100644
--- a/OgreMain/CMakeLists.txt
+++ b/OgreMain/CMakeLists.txt
@@ -216,10 +216,10 @@ if (APPLE)
   endif()
 endif ()
 target_link_libraries(OgreMain PUBLIC ${PLATFORM_LIBS} PRIVATE ${LIBRARIES} ${CMAKE_DL_LIBS})
-
+if (!APPLE)
 # specify a precompiled header to use
 add_native_precompiled_header(OgreMain "$<$<COMPILE_LANGUAGE:CXX>:${CMAKE_CURRENT_SOURCE_DIR}/src/OgreStableHeaders.h>")
-
+endif ()
 # install OgreMain
 ogre_config_lib(OgreMain TRUE)
 install(FILES ${HEADER_FILES}
diff --git a/OgreMain/src/OgreRoot.cpp b/OgreMain/src/OgreRoot.cpp
index 7100c33..11c636e 100644
--- a/OgreMain/src/OgreRoot.cpp
+++ b/OgreMain/src/OgreRoot.cpp
@@ -911,7 +911,7 @@ namespace Ogre {
     //-----------------------------------------------------------------------
     void Root::unloadPlugins(void)
     {
-#if OGRE_PLATFORM != OGRE_PLATFORM_EMSCRIPTEN
+#ifndef OGRE_STATIC_LIB
         // unload dynamic libs first
         for (PluginLibList::reverse_iterator i = mPluginLibs.rbegin(); i != mPluginLibs.rend(); ++i)
         {
@@ -1071,7 +1071,7 @@ namespace Ogre {
     //-----------------------------------------------------------------------
     void Root::loadPlugin(const String& pluginName)
     {
-#if OGRE_PLATFORM != OGRE_PLATFORM_EMSCRIPTEN
+#ifndef OGRE_STATIC_LIB
         // Load plugin library
         DynLib* lib = DynLibManager::getSingleton().load( pluginName );
         // Store for later unload
@@ -1098,7 +1098,7 @@ namespace Ogre {
     //-----------------------------------------------------------------------
     void Root::unloadPlugin(const String& pluginName)
     {
-#if OGRE_PLATFORM != OGRE_PLATFORM_EMSCRIPTEN
+#ifndef OGRE_STATIC_LIB
         PluginLibList::iterator i;
 
         for (i = mPluginLibs.begin(); i != mPluginLibs.end(); ++i)
diff --git a/OgreMain/src/OgreShadowCameraSetupPSSM.cpp b/OgreMain/src/OgreShadowCameraSetupPSSM.cpp
index 560ac60..539c2e8 100644
--- a/OgreMain/src/OgreShadowCameraSetupPSSM.cpp
+++ b/OgreMain/src/OgreShadowCameraSetupPSSM.cpp
@@ -50,9 +50,9 @@ namespace Ogre
     //---------------------------------------------------------------------
     void PSSMShadowCameraSetup::calculateSplitPoints(uint splitCount, Real nearDist, Real farDist, Real lambda)
     {
-        if (splitCount < 2)
-            OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, "Cannot specify less than 2 splits", 
-            "PSSMShadowCameraSetup::calculateSplitPoints");
+        //if (splitCount < 2)
+            //OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, "Cannot specify less than 2 splits",
+            //"PSSMShadowCameraSetup::calculateSplitPoints");
 
         mSplitPoints.resize(splitCount + 1);
         mOptimalAdjustFactors.resize(splitCount);
diff --git a/OgreMain/src/OgreShadowRenderer.cpp b/OgreMain/src/OgreShadowRenderer.cpp
index 3b320f7..69edddd 100644
--- a/OgreMain/src/OgreShadowRenderer.cpp
+++ b/OgreMain/src/OgreShadowRenderer.cpp
@@ -757,7 +757,7 @@ void SceneManager::ShadowRenderer::prepareShadowTextures(Camera* cam, Viewport*
     else
     {
         // disable fogging explicitly
-        mShadowReceiverPass->setFog(true, FOG_NONE);
+        //mShadowReceiverPass->setFog(true, FOG_NONE);
     }
 
     // Iterate over the lights we've found, max out at the limit of light textures
@@ -1297,7 +1297,7 @@ void SceneManager::ShadowRenderer::initShadowVolumeMaterials()
      */
     OgreAssert( mDestRenderSystem, "no RenderSystem");
 
-    if (mShadowMaterialInitDone)
+    if (mShadowMaterialInitDone = true)
         return;
 
     if (!mShadowDebugPass)
diff --git a/PlugIns/STBICodec/CMakeLists.txt b/PlugIns/STBICodec/CMakeLists.txt
index 10283f5..8cb4ec1 100644
--- a/PlugIns/STBICodec/CMakeLists.txt
+++ b/PlugIns/STBICodec/CMakeLists.txt
@@ -28,7 +28,7 @@ if(CMAKE_COMPILER_IS_GNUCXX)
   target_link_libraries(Codec_STBI PRIVATE gcc)
 endif()
 
-if(ZLIB_FOUND)
+if(0)
   target_compile_definitions(Codec_STBI PRIVATE HAVE_ZLIB)
   target_link_libraries(Codec_STBI PRIVATE ZLIB::ZLIB)
 endif()
diff --git a/PlugIns/STBICodec/src/OgreSTBICodec.cpp b/PlugIns/STBICodec/src/OgreSTBICodec.cpp
index f89e9a1..eec4a06 100644
--- a/PlugIns/STBICodec/src/OgreSTBICodec.cpp
+++ b/PlugIns/STBICodec/src/OgreSTBICodec.cpp
@@ -41,7 +41,7 @@ THE SOFTWARE.
 #define STB_IMAGE_IMPLEMENTATION
 #define STB_IMAGE_STATIC
 #include "stbi/stb_image.h"
-
+#undef HAVE_ZLIB
 #ifdef HAVE_ZLIB
 #include <zlib.h>
 static Ogre::uchar* custom_zlib_compress(Ogre::uchar* data, int data_len, int* out_len, int /*quality*/)
diff --git a/RenderSystems/GL3Plus/src/OgreGL3PlusPixelFormat.cpp b/RenderSystems/GL3Plus/src/OgreGL3PlusPixelFormat.cpp
index f1f6c5d..415c92f 100644
--- a/RenderSystems/GL3Plus/src/OgreGL3PlusPixelFormat.cpp
+++ b/RenderSystems/GL3Plus/src/OgreGL3PlusPixelFormat.cpp
@@ -180,7 +180,7 @@ namespace Ogre  {
             {GL_NONE, GL_NONE, GL_COMPRESSED_RGBA_ASTC_12x12_KHR},// PF_ASTC_RGBA_12X12_LDR
             {GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, GL_DEPTH_COMPONENT32}, // PF_DEPTH32
             {GL_DEPTH_COMPONENT, GL_FLOAT, GL_DEPTH_COMPONENT32F}, // PF_DEPTH32F
-            {GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, GL_DEPTH24_STENCIL8}, // PF_DEPTH24_STENCIL8
+            {GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, GL_DEPTH_COMPONENT24}, // PF_DEPTH24_STENCIL8
     };
 
     GLenum GL3PlusPixelUtil::getGLOriginFormat(PixelFormat pf)
diff --git a/RenderSystems/GLES2/src/GLSLES/src/OgreGLSLESLinkProgram.cpp b/RenderSystems/GLES2/src/GLSLES/src/OgreGLSLESLinkProgram.cpp
index 5cb0520..4d5a1e5 100644
--- a/RenderSystems/GLES2/src/GLSLES/src/OgreGLSLESLinkProgram.cpp
+++ b/RenderSystems/GLES2/src/GLSLES/src/OgreGLSLESLinkProgram.cpp
@@ -199,7 +199,7 @@ namespace Ogre {
                     GLsizei glArraySize = (GLsizei)def->arraySize;
 
                     // this is a monolitic program so we can use the cache of any attached shader
-                    GLUniformCache* uniformCache =  mShaders[GPT_VERTEX_PROGRAM]->getUniformCache();
+                    GLUniformCache* uniformCache =  mShaders[GPT_FRAGMENT_PROGRAM]->getUniformCache();
                     void* val = def->isSampler() ? (void*)params->getRegPointer(def->physicalIndex)
                                                  : (void*)params->getFloatPointer(def->physicalIndex);
 
diff --git a/RenderSystems/GLES2/src/OgreGLES2HardwarePixelBuffer.cpp b/RenderSystems/GLES2/src/OgreGLES2HardwarePixelBuffer.cpp
index 2b1a1f5..a4c498b 100644
--- a/RenderSystems/GLES2/src/OgreGLES2HardwarePixelBuffer.cpp
+++ b/RenderSystems/GLES2/src/OgreGLES2HardwarePixelBuffer.cpp
@@ -122,7 +122,7 @@ namespace Ogre {
           mLevel(level)
     {
         // Get face identifier
-        mFaceTarget = mTarget;
+        mFaceTarget = mTarget; mUsage &= ~TU_AUTOMIPMAP;
         if(mTarget == GL_TEXTURE_CUBE_MAP)
             mFaceTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + face;
 
diff --git a/RenderSystems/GLES2/src/OgreGLES2PixelFormat.cpp b/RenderSystems/GLES2/src/OgreGLES2PixelFormat.cpp
index 7e1578e..09b3549 100644
--- a/RenderSystems/GLES2/src/OgreGLES2PixelFormat.cpp
+++ b/RenderSystems/GLES2/src/OgreGLES2PixelFormat.cpp
@@ -265,9 +265,9 @@ namespace Ogre {
             {GL_NONE, GL_NONE, GL_COMPRESSED_RGBA_ASTC_10x10_KHR},// PF_ASTC_RGBA_10X10_LDR
             {GL_NONE, GL_NONE, GL_COMPRESSED_RGBA_ASTC_12x10_KHR},// PF_ASTC_RGBA_12X10_LDR
             {GL_NONE, GL_NONE, GL_COMPRESSED_RGBA_ASTC_12x12_KHR},// PF_ASTC_RGBA_12X12_LDR
-            {GL_NONE, GL_NONE, GL_NONE}, // PF_DEPTH32
+            {GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, GL_DEPTH_COMPONENT32_OES}, // PF_DEPTH32
             {GL_NONE, GL_NONE, GL_NONE}, // PF_DEPTH32F
-            {GL_NONE, GL_NONE, GL_NONE}, // PF_DEPTH24_STENCIL8
+            {GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, GL_DEPTH_COMPONENT24_OES}, // PF_DEPTH24_STENCIL8
     };
 
     void GLES2PixelUtil::useSizedFormats()
diff --git a/RenderSystems/GLSupport/CMakeLists.txt b/RenderSystems/GLSupport/CMakeLists.txt
index e591cb2..3a5b9e1 100644
--- a/RenderSystems/GLSupport/CMakeLists.txt
+++ b/RenderSystems/GLSupport/CMakeLists.txt
@@ -104,7 +104,7 @@ elseif (UNIX)
   endif()
 endif ()
 
-file(GLOB GLSUPPORT_HEADERS "${CMAKE_CURRENT_SOURCE_DIR}/include/*.h")
+file(GLOB GLSUPPORT_HEADERS "${CMAKE_CURRENT_SOURCE_DIR}/include/*.h" "${CMAKE_CURRENT_SOURCE_DIR}/include/GLSL/*.h")
 set(GLSUPPORT_HEADERS ${GLSUPPORT_HEADERS} ${PROJECT_BINARY_DIR}/include/OgreGLSupportPrerequisites.h PARENT_SCOPE)
 
 file(GLOB GLSL_SOURCES src/GLSL/*.cpp)
diff --git a/RenderSystems/GLSupport/src/EGL/OgreEGLContext.cpp b/RenderSystems/GLSupport/src/EGL/OgreEGLContext.cpp
index 9277d4e..1778d4e 100644
--- a/RenderSystems/GLSupport/src/EGL/OgreEGLContext.cpp
+++ b/RenderSystems/GLSupport/src/EGL/OgreEGLContext.cpp
@@ -49,7 +49,7 @@ namespace Ogre {
           mContext(0),
           mExternalContext(false)
     {
-        assert(drawable);
+        //assert(drawable);
         GLRenderSystemCommon* renderSystem = static_cast<GLRenderSystemCommon*>(Root::getSingleton().getRenderSystem());
         EGLContext* mainContext = static_cast<EGLContext*>(renderSystem->_getMainContext());
         ::EGLContext shareContext = (::EGLContext) 0;
diff --git a/RenderSystems/GLSupport/src/EGL/OgreEGLWindow.cpp b/RenderSystems/GLSupport/src/EGL/OgreEGLWindow.cpp
index 0c5d932..209508b 100644
--- a/RenderSystems/GLSupport/src/EGL/OgreEGLWindow.cpp
+++ b/RenderSystems/GLSupport/src/EGL/OgreEGLWindow.cpp
@@ -215,7 +215,7 @@ namespace Ogre {
 #if OGRE_PLATFORM == OGRE_PLATFORM_EMSCRIPTEN
         int* gamma_attribs = NULL;
 #else
-        int gamma_attribs[] = {EGL_GL_COLORSPACE_KHR, EGL_GL_COLORSPACE_SRGB_KHR, EGL_NONE};
+        int gamma_attribs[] = {EGL_NONE};
 #endif
         mHwGamma = mHwGamma && mGLSupport->checkExtension("EGL_KHR_gl_colorspace");
 
diff --git a/RenderSystems/GLSupport/src/GLSL/OgreGLSLShaderCommon.cpp b/RenderSystems/GLSupport/src/GLSL/OgreGLSLShaderCommon.cpp
index 436c498..45cab51 100644
--- a/RenderSystems/GLSupport/src/GLSL/OgreGLSLShaderCommon.cpp
+++ b/RenderSystems/GLSupport/src/GLSL/OgreGLSLShaderCommon.cpp
@@ -83,8 +83,8 @@ namespace Ogre {
             mSource.replace(
                 versionPos, 34,
                 StringUtil::format("#version %d%s", mShaderVersion, (isGLES && mShaderVersion > 100) ? " es" : ""));
-        }
-
+        } else { mShaderVersion = renderSystem ? renderSystem->getNativeShadingLanguageVersion() : 120; // should check, if there is free space for replace, but for it is chip and dirty
+            mSource.replace(0, 18,StringUtil::format("#version %d%s\n//", mShaderVersion, (isGLES && mShaderVersion > 100) ? " es" : (mShaderVersion > 300 ? " core" : ""))); }
         String verStr = std::to_string(mShaderVersion);
 
 #if OGRE_PLATFORM == OGRE_PLATFORM_APPLE
diff --git a/RenderSystems/GLSupport/src/OSX/OgreOSXCocoaWindow.mm b/RenderSystems/GLSupport/src/OSX/OgreOSXCocoaWindow.mm
index 269a2a1..9a3f9a4 100644
--- a/RenderSystems/GLSupport/src/OSX/OgreOSXCocoaWindow.mm
+++ b/RenderSystems/GLSupport/src/OSX/OgreOSXCocoaWindow.mm
@@ -410,8 +410,8 @@ namespace Ogre {
     unsigned int CocoaWindow::getWidth() const
     {
         // keep mWidth in sync with reality
-        OgreAssertDbg(mView == nil || int(mWidth) == _getPixelFromPoint([mView frame].size.width),
-                      "Window dimension mismatch. Did you call windowMovedOrResized?");
+        //OgreAssertDbg(mView == nil || int(mWidth) == _getPixelFromPoint([mView frame].size.width),
+                      //"Window dimension mismatch. Did you call windowMovedOrResized?");
 
         return mWidth;
     }
@@ -419,8 +419,8 @@ namespace Ogre {
     unsigned int CocoaWindow::getHeight() const
     {
         // keep mHeight in sync with reality
-        OgreAssertDbg(mView == nil || int(mHeight) == _getPixelFromPoint([mView frame].size.height),
-                      "Window dimension mismatch. Did you call windowMovedOrResized?");
+        //OgreAssertDbg(mView == nil || int(mHeight) == _getPixelFromPoint([mView frame].size.height),
+                      //"Window dimension mismatch. Did you call windowMovedOrResized?");
 
         return mHeight;
     }
