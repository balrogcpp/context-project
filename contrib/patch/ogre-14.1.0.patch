diff --git a/CMake/Templates/imconfig.h b/CMake/Templates/imconfig.h
index 7f6a28ce2..861009898 100644
--- a/CMake/Templates/imconfig.h
+++ b/CMake/Templates/imconfig.h
@@ -1,5 +1,6 @@
 #pragma once
 #define IMGUI_DISABLE_OBSOLETE_FUNCTIONS
+#define IMGUI_USE_WCHAR32
 #include <OgreOverlayPrerequisites.h>
 #define IMGUI_API _OgreOverlayExport
 #cmakedefine IMGUI_ENABLE_FREETYPE
\ No newline at end of file
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 33b6e8e75..081492c86 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -263,12 +263,12 @@ elseif(EMSCRIPTEN)
   set(OGRE_BUILD_PLUGIN_BSP FALSE CACHE BOOL "Disable pcz on Emscripten" FORCE)
   set(OGRE_BUILD_TOOLS FALSE CACHE BOOL "Disable tools on Emscripten" FORCE)
   set(OGRE_BUILD_TESTS FALSE CACHE BOOL "Disable tests on Emscripten" FORCE)
-  set(OGRE_BUILD_COMPONENT_VOLUME FALSE CACHE BOOL "Disable volume component on Emscripten" FORCE)
+  #set(OGRE_BUILD_COMPONENT_VOLUME FALSE CACHE BOOL "Disable volume component on Emscripten" FORCE)
   set(OGRE_BUILD_COMPONENT_PAGING FALSE CACHE BOOL "Disable paging component on Emscripten" FORCE)
-  set(OGRE_BUILD_COMPONENT_TERRAIN FALSE CACHE BOOL "Disable terrain component on Emscripten" FORCE)
+  #set(OGRE_BUILD_COMPONENT_TERRAIN FALSE CACHE BOOL "Disable terrain component on Emscripten" FORCE)
   set(OGRE_STATIC TRUE CACHE BOOL "Forcing static build for Emscripten" FORCE)
 
-  set(OGRE_CONFIG_THREADS "0" CACHE STRING "Threading is unstable on Emscripten" FORCE)
+  #set(OGRE_CONFIG_THREADS "0" CACHE STRING "Threading is unstable on Emscripten" FORCE)
 elseif (APPLE AND NOT APPLE_IOS)
   # Make sure that the GLES2 render system is disabled for non-iOS Apple builds
   set(OGRE_BUILD_RENDERSYSTEM_GLES2 FALSE CACHE BOOL "" FORCE)
@@ -376,7 +376,7 @@ cmake_dependent_option(OGRE_INSTALL_SAMPLES "Install Ogre demos." TRUE "OGRE_BUI
 option(OGRE_INSTALL_TOOLS "Install Ogre tools." TRUE)
 option(OGRE_INSTALL_DOCS "Install documentation." TRUE)
 cmake_dependent_option(OGRE_INSTALL_PDB "Install debug pdb files" TRUE "MSVC" FALSE)
-option(OGRE_PROFILING "Enable internal instrumentation." FALSE)
+cmake_dependent_option(OGRE_PROFILING "Enable internal instrumentation." TRUE "${CMAKE_BUILD_TYPE} MATCHES Debug OR ${CMAKE_BUILD_TYPE} MATCHES RelWithDebInfo" FALSE)
 set(OGRE_PROFILING_REMOTERY_PATH "" CACHE PATH "set this to Remotery/lib to use Remotery instead of the buildin profiler")
 cmake_dependent_option(OGRE_CONFIG_STATIC_LINK_CRT "Statically link the MS CRT dlls (msvcrt)" FALSE "MSVC" FALSE)
 set(OGRE_LIB_DIRECTORY "lib${LIB_SUFFIX}" CACHE STRING "Install path for libraries, e.g. 'lib64' on some 64-bit Linux distros.")
diff --git a/Components/Overlay/CMakeLists.txt b/Components/Overlay/CMakeLists.txt
index 9b6f7908f..5df4a47ba 100644
--- a/Components/Overlay/CMakeLists.txt
+++ b/Components/Overlay/CMakeLists.txt
@@ -90,7 +90,7 @@ if(OGRE_BUILD_COMPONENT_OVERLAY_IMGUI)
   configure_file(${OGRE_TEMPLATES_DIR}/imconfig.h ${IMGUI_DIR}/imconfig.h)
 
   list(APPEND HEADER_FILES
-    ${IMGUI_DIR}/imgui.h
+    ${IMGUI_DIR}/imgui.h ${IMGUI_DIR}/imgui_internal.h ${IMGUI_DIR}/imstb_textedit.h ${IMGUI_DIR}/imstb_truetype.h ${IMGUI_DIR}/imstb_rectpack.h
     ${IMGUI_DIR}/imconfig.h)
 endif()
 
diff --git a/Components/Overlay/src/OgreOverlayProfileSessionListener.cpp b/Components/Overlay/src/OgreOverlayProfileSessionListener.cpp
index 8b210c1f0..049d9c0af 100644
--- a/Components/Overlay/src/OgreOverlayProfileSessionListener.cpp
+++ b/Components/Overlay/src/OgreOverlayProfileSessionListener.cpp
@@ -108,7 +108,7 @@ namespace Ogre
     void OverlayProfileSessionListener::finializeSession()
     {
         OverlayContainer* container = dynamic_cast<OverlayContainer*>(mProfileGui);
-        if (container)
+        if (0)
         {
             for (const auto& p : container->getChildren())
             {
@@ -122,7 +122,7 @@ namespace Ogre
             OverlayManager::getSingleton().destroyOverlayElement(mProfileGui);
         if(mOverlay)
             OverlayManager::getSingleton().destroy(mOverlay);
-
+        OverlayManager::getSingleton().destroyAllOverlayElements();
         mProfileBars.clear();
     }
     //-----------------------------------------------------------------------
diff --git a/Components/Terrain/include/OgreTerrainQuadTreeNode.h b/Components/Terrain/include/OgreTerrainQuadTreeNode.h
index e2e18a155..1a2146106 100644
--- a/Components/Terrain/include/OgreTerrainQuadTreeNode.h
+++ b/Components/Terrain/include/OgreTerrainQuadTreeNode.h
@@ -77,7 +77,7 @@ namespace Ogre
         the same (relative) LOD index no matter where you are in the tree, therefore
         buffers can potentially be reused more easily.
     */
-    class _OgreTerrainExport TerrainQuadTreeNode : private Renderable, private MovableObject
+    class _OgreTerrainExport TerrainQuadTreeNode : public Renderable, public MovableObject
     {
     public:
         /** Constructor.
diff --git a/Components/Terrain/src/OgreTerrain.cpp b/Components/Terrain/src/OgreTerrain.cpp
index e0d5d7716..1650982ba 100644
--- a/Components/Terrain/src/OgreTerrain.cpp
+++ b/Components/Terrain/src/OgreTerrain.cpp
@@ -4134,7 +4134,7 @@ namespace Ogre
         else
         {
             // float3 position
-            sz += sizeof(float) * 3;
+            sz += sizeof(float) * 3; if(0) sz += sizeof(float) * 6; // + normal + tangent
             // float2 uv
             sz += sizeof(float) * 2;
         }
diff --git a/Components/Terrain/src/OgreTerrainQuadTreeNode.cpp b/Components/Terrain/src/OgreTerrainQuadTreeNode.cpp
index 1093d6bc6..9af09fa3b 100644
--- a/Components/Terrain/src/OgreTerrainQuadTreeNode.cpp
+++ b/Components/Terrain/src/OgreTerrainQuadTreeNode.cpp
@@ -178,7 +178,7 @@ namespace Ogre
             for (int i = 0; i < 4; ++i)
                 mChildren[i]->prepare();
         }
-
+        setCastShadows(TerrainGlobalOptions::getSingleton().getCastsDynamicShadows());
     }
     //---------------------------------------------------------------------
     void TerrainQuadTreeNode::prepare(StreamSerialiser& stream)
@@ -587,7 +587,7 @@ namespace Ogre
                 // 28 bytes per vertex, compatibility
                 // POSITION
                 // float3(x, y, z)
-                offset += dcl->addElement(POSITION_BUFFER, offset, VET_FLOAT3, VES_POSITION).getSize();
+                offset += dcl->addElement(POSITION_BUFFER, offset, VET_FLOAT3, VES_POSITION).getSize(); if(0){offset += dcl->addElement(POSITION_BUFFER, offset, VET_FLOAT3, VES_NORMAL).getSize(); offset += dcl->addElement(POSITION_BUFFER, offset, VET_FLOAT3, VES_TANGENT).getSize();}
                 // UV0
                 // float2(u, v)
                 dcl->addElement(POSITION_BUFFER, offset, VET_FLOAT2, VES_TEXTURE_COORDINATES, 0).getSize();
@@ -893,7 +893,7 @@ namespace Ogre
             *pPosBuf++ = pos.x;
             *pPosBuf++ = pos.y;
             *pPosBuf++ = pos.z;
-
+            if(0){Vector3 n = Vector3::ZERO, t, c, adj[8]; mTerrain->getPointFromSelfOrNeighbour(x, y ,&c); mTerrain->getPointFromSelfOrNeighbour(x+1, y, &adj[0]); mTerrain->getPointFromSelfOrNeighbour(x+1, y+1, &adj[1]); mTerrain->getPointFromSelfOrNeighbour(x, y+1, &adj[2]); mTerrain->getPointFromSelfOrNeighbour(x-1, y+1, &adj[3]); mTerrain->getPointFromSelfOrNeighbour(x-1, y, &adj[4]); mTerrain->getPointFromSelfOrNeighbour(x-1, y-1, &adj[5]); mTerrain->getPointFromSelfOrNeighbour(x, y-1, &adj[6]); mTerrain->getPointFromSelfOrNeighbour(x+1, y-1, &adj[7]); for (int i = 0; i < 8; ++i) n += Math::calculateBasicFaceNormal(c, adj[i], adj[(i+1)%8]); n.normalise(); *pPosBuf++ = n.x; *pPosBuf++ = n.y; *pPosBuf++ = n.z; t = adj[4].x >= 0.0 ? adj[4] - c : c - adj[0]; t.normalise(); *pPosBuf++ = t.x; *pPosBuf++ = t.y; *pPosBuf++ = t.z;}
             // UVs - base UVs vary from 0 to 1, all other values
             // will be derived using scalings
             *pPosBuf++ = x * uvScale;
diff --git a/OgreMain/CMakeLists.txt b/OgreMain/CMakeLists.txt
index df19a5115..33f2e3f29 100644
--- a/OgreMain/CMakeLists.txt
+++ b/OgreMain/CMakeLists.txt
@@ -216,10 +216,10 @@ if (APPLE)
   endif()
 endif ()
 target_link_libraries(OgreMain PUBLIC ${PLATFORM_LIBS} PRIVATE ${LIBRARIES} ${CMAKE_DL_LIBS})
-
+if (!APPLE)
 # specify a precompiled header to use
 add_native_precompiled_header(OgreMain "$<$<COMPILE_LANGUAGE:CXX>:${CMAKE_CURRENT_SOURCE_DIR}/src/OgreStableHeaders.h>")
-
+endif ()
 # install OgreMain
 ogre_config_lib(OgreMain TRUE)
 install(FILES ${HEADER_FILES}
diff --git a/OgreMain/include/OgreException.h b/OgreMain/include/OgreException.h
index 5e06c1945..ee4cf91e9 100644
--- a/OgreMain/include/OgreException.h
+++ b/OgreMain/include/OgreException.h
@@ -69,7 +69,7 @@ THE SOFTWARE.
 /// replaced with OgreAssert(expr, mesg) in Debug configuration
 #   define OgreAssertDbg( expr, mesg )
 #endif
-
+#define OgreAssertDbg2( a ) OgreAssertDbg( a, #a )
 namespace Ogre {
 
     /** \addtogroup Core
@@ -272,12 +272,18 @@ namespace Ogre {
             }
         }
     public:
+#if defined(_MSC_VER) && defined(_DEBUG)
         static OGRE_NORETURN void throwException(
+#else
+        static void throwException(
+#endif
             Exception::ExceptionCodes code,
             const String& desc,
             const String& src, const char* file, long line)
         {
+#if OGRE_ASSERT_MODE == 2 || (OGRE_ASSERT_MODE == 1 && !defined(OGRE_DEBUG_MODE))
             _throwException(code, code, desc, src, file, line);
+#endif
         }
     };
     
diff --git a/OgreMain/src/OgreAutoParamDataSource.cpp b/OgreMain/src/OgreAutoParamDataSource.cpp
index e35af3943..680f7415a 100644
--- a/OgreMain/src/OgreAutoParamDataSource.cpp
+++ b/OgreMain/src/OgreAutoParamDataSource.cpp
@@ -351,7 +351,7 @@ namespace Ogre {
             }
             else
             {
-                mProjectionMatrix = mCurrentCamera->getProjectionMatrixWithRSDepth();
+                mProjectionMatrix = mCurrentCamera->getProjectionMatrix();
             }
             if (mCurrentRenderTarget && mCurrentRenderTarget->requiresTextureFlipping())
             {
@@ -685,14 +685,14 @@ namespace Ogre {
                         mCurrentCamera->getDerivedPosition(), viewMatrix);
                     mTextureViewProjMatrix[index] = 
                         Matrix4::CLIPSPACE2DTOIMAGESPACE *
-                        mCurrentTextureProjector[index]->getProjectionMatrixWithRSDepth() * 
+                        mCurrentTextureProjector[index]->getProjectionMatrix() *
                         viewMatrix;
                 }
                 else
                 {
                     mTextureViewProjMatrix[index] = 
                         Matrix4::CLIPSPACE2DTOIMAGESPACE *
-                        mCurrentTextureProjector[index]->getProjectionMatrixWithRSDepth() * 
+                        mCurrentTextureProjector[index]->getProjectionMatrix() *
                         mCurrentTextureProjector[index]->getViewMatrix();
                 }
                 mTextureViewProjMatrixDirty[index] = false;
@@ -757,7 +757,7 @@ namespace Ogre {
                 // since they are built into the frustum position
                 mSpotlightViewProjMatrix[index] = 
                     Matrix4::CLIPSPACE2DTOIMAGESPACE *
-                    frust.getProjectionMatrixWithRSDepth() * 
+                    frust.getProjectionMatrix() *
                     frust.getViewMatrix();
 
                 mSpotlightViewProjMatrixDirty[index] = false;
diff --git a/OgreMain/src/OgreRoot.cpp b/OgreMain/src/OgreRoot.cpp
index dc4684669..17bf6854c 100644
--- a/OgreMain/src/OgreRoot.cpp
+++ b/OgreMain/src/OgreRoot.cpp
@@ -912,7 +912,7 @@ namespace Ogre {
     //-----------------------------------------------------------------------
     void Root::unloadPlugins(void)
     {
-#if OGRE_PLATFORM != OGRE_PLATFORM_EMSCRIPTEN
+#ifndef OGRE_STATIC_LIB
         // unload dynamic libs first
         for (PluginLibList::reverse_iterator i = mPluginLibs.rbegin(); i != mPluginLibs.rend(); ++i)
         {
@@ -1072,7 +1072,7 @@ namespace Ogre {
     //-----------------------------------------------------------------------
     void Root::loadPlugin(const String& pluginName)
     {
-#if OGRE_PLATFORM != OGRE_PLATFORM_EMSCRIPTEN
+#ifndef OGRE_STATIC_LIB
         // Load plugin library
         DynLib* lib = DynLibManager::getSingleton().load( pluginName );
         // Store for later unload
@@ -1099,7 +1099,7 @@ namespace Ogre {
     //-----------------------------------------------------------------------
     void Root::unloadPlugin(const String& pluginName)
     {
-#if OGRE_PLATFORM != OGRE_PLATFORM_EMSCRIPTEN
+#ifndef OGRE_STATIC_LIB
         PluginLibList::iterator i;
 
         for (i = mPluginLibs.begin(); i != mPluginLibs.end(); ++i)
diff --git a/OgreMain/src/OgreShadowCameraSetupFocused.cpp b/OgreMain/src/OgreShadowCameraSetupFocused.cpp
index 9a76f0291..9ac3ae468 100644
--- a/OgreMain/src/OgreShadowCameraSetupFocused.cpp
+++ b/OgreMain/src/OgreShadowCameraSetupFocused.cpp
@@ -106,6 +106,16 @@ namespace Ogre
         {
             // For directional lights, all we care about is projecting the receivers
             // backwards towards the light, clipped by the camera region
+            if (float dot = cam.getDerivedDirection().dotProduct(light.getDerivedDirection()) > 0.0) {
+                mBodyB.extend(-light.getDerivedDirection()*0.5*cam.getFarClipDistance());
+                mBodyB.extend(-light.getDerivedDirection().crossProduct(Vector3::UNIT_X)*0.5*cam.getFarClipDistance());
+                mBodyB.extend(-light.getDerivedDirection().crossProduct(Vector3::UNIT_Y)*0.5*cam.getFarClipDistance());
+                mBodyB.extend(-light.getDerivedDirection().crossProduct(Vector3::UNIT_Z)*0.5*cam.getFarClipDistance());
+                mBodyB.extend(light.getDerivedDirection()*0.5*cam.getFarClipDistance());
+                mBodyB.extend(light.getDerivedDirection().crossProduct(Vector3::UNIT_X)*0.5*cam.getFarClipDistance());
+                mBodyB.extend(light.getDerivedDirection().crossProduct(Vector3::UNIT_Y)*0.5*cam.getFarClipDistance());
+                mBodyB.extend(light.getDerivedDirection().crossProduct(Vector3::UNIT_Z)*0.5*cam.getFarClipDistance());
+            }
             mBodyB.clip(receiverBB.intersection(sceneBB));
 
             // Also clip based on shadow far distance if appropriate
diff --git a/OgreMain/src/OgreShadowCameraSetupPSSM.cpp b/OgreMain/src/OgreShadowCameraSetupPSSM.cpp
index 560ac60b0..539c2e820 100644
--- a/OgreMain/src/OgreShadowCameraSetupPSSM.cpp
+++ b/OgreMain/src/OgreShadowCameraSetupPSSM.cpp
@@ -50,9 +50,9 @@ namespace Ogre
     //---------------------------------------------------------------------
     void PSSMShadowCameraSetup::calculateSplitPoints(uint splitCount, Real nearDist, Real farDist, Real lambda)
     {
-        if (splitCount < 2)
-            OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, "Cannot specify less than 2 splits", 
-            "PSSMShadowCameraSetup::calculateSplitPoints");
+        //if (splitCount < 2)
+            //OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, "Cannot specify less than 2 splits",
+            //"PSSMShadowCameraSetup::calculateSplitPoints");
 
         mSplitPoints.resize(splitCount + 1);
         mOptimalAdjustFactors.resize(splitCount);
diff --git a/OgreMain/src/OgreShadowRenderer.cpp b/OgreMain/src/OgreShadowRenderer.cpp
index 25c1bf4c3..3f019b150 100644
--- a/OgreMain/src/OgreShadowRenderer.cpp
+++ b/OgreMain/src/OgreShadowRenderer.cpp
@@ -757,7 +757,7 @@ void SceneManager::ShadowRenderer::prepareShadowTextures(Camera* cam, Viewport*
     else
     {
         // disable fogging explicitly
-        mShadowReceiverPass->setFog(true, FOG_NONE);
+        //mShadowReceiverPass->setFog(true, FOG_NONE);
     }
 
     // Iterate over the lights we've found, max out at the limit of light textures
@@ -1297,7 +1297,7 @@ void SceneManager::ShadowRenderer::initShadowVolumeMaterials()
      */
     OgreAssert( mDestRenderSystem, "no RenderSystem");
 
-    if (mShadowMaterialInitDone)
+    if (mShadowMaterialInitDone = true)
         return;
 
     if (!mShadowDebugPass)
diff --git a/PlugIns/STBICodec/src/OgreSTBICodec.cpp b/PlugIns/STBICodec/src/OgreSTBICodec.cpp
index f89e9a16c..eec4a06c8 100644
--- a/PlugIns/STBICodec/src/OgreSTBICodec.cpp
+++ b/PlugIns/STBICodec/src/OgreSTBICodec.cpp
@@ -41,7 +41,7 @@ THE SOFTWARE.
 #define STB_IMAGE_IMPLEMENTATION
 #define STB_IMAGE_STATIC
 #include "stbi/stb_image.h"
-
+#undef HAVE_ZLIB
 #ifdef HAVE_ZLIB
 #include <zlib.h>
 static Ogre::uchar* custom_zlib_compress(Ogre::uchar* data, int data_len, int* out_len, int /*quality*/)
diff --git a/RenderSystems/GLES2/src/GLSLES/src/OgreGLSLESLinkProgram.cpp b/RenderSystems/GLES2/src/GLSLES/src/OgreGLSLESLinkProgram.cpp
index 5cb052037..4d5a1e514 100644
--- a/RenderSystems/GLES2/src/GLSLES/src/OgreGLSLESLinkProgram.cpp
+++ b/RenderSystems/GLES2/src/GLSLES/src/OgreGLSLESLinkProgram.cpp
@@ -199,7 +199,7 @@ namespace Ogre {
                     GLsizei glArraySize = (GLsizei)def->arraySize;
 
                     // this is a monolitic program so we can use the cache of any attached shader
-                    GLUniformCache* uniformCache =  mShaders[GPT_VERTEX_PROGRAM]->getUniformCache();
+                    GLUniformCache* uniformCache =  mShaders[GPT_FRAGMENT_PROGRAM]->getUniformCache();
                     void* val = def->isSampler() ? (void*)params->getRegPointer(def->physicalIndex)
                                                  : (void*)params->getFloatPointer(def->physicalIndex);
 
diff --git a/RenderSystems/GLES2/src/OgreGLES2HardwarePixelBuffer.cpp b/RenderSystems/GLES2/src/OgreGLES2HardwarePixelBuffer.cpp
index 663dc69bf..cf41e9b1f 100644
--- a/RenderSystems/GLES2/src/OgreGLES2HardwarePixelBuffer.cpp
+++ b/RenderSystems/GLES2/src/OgreGLES2HardwarePixelBuffer.cpp
@@ -122,7 +122,7 @@ namespace Ogre {
           mLevel(level)
     {
         // Get face identifier
-        mFaceTarget = mTarget;
+        mFaceTarget = mTarget; mUsage &= ~TU_AUTOMIPMAP;
         if(mTarget == GL_TEXTURE_CUBE_MAP)
             mFaceTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + face;
 
diff --git a/RenderSystems/GLSupport/src/EGL/Android/OgreAndroidEGLWindow.cpp b/RenderSystems/GLSupport/src/EGL/Android/OgreAndroidEGLWindow.cpp
index 8c875176a..e809baf54 100644
--- a/RenderSystems/GLSupport/src/EGL/Android/OgreAndroidEGLWindow.cpp
+++ b/RenderSystems/GLSupport/src/EGL/Android/OgreAndroidEGLWindow.cpp
@@ -127,6 +127,7 @@ namespace Ogre {
                                 "EGLWindow::create");
                 }
 
+                mEglSurface = eglGetCurrentSurface(EGL_DRAW);
                 mEglDisplay = eglGetCurrentDisplay();
             }
 
diff --git a/RenderSystems/GLSupport/src/EGL/OgreEGLContext.cpp b/RenderSystems/GLSupport/src/EGL/OgreEGLContext.cpp
index 9277d4eb1..1778d4ed8 100644
--- a/RenderSystems/GLSupport/src/EGL/OgreEGLContext.cpp
+++ b/RenderSystems/GLSupport/src/EGL/OgreEGLContext.cpp
@@ -49,7 +49,7 @@ namespace Ogre {
           mContext(0),
           mExternalContext(false)
     {
-        assert(drawable);
+        //assert(drawable);
         GLRenderSystemCommon* renderSystem = static_cast<GLRenderSystemCommon*>(Root::getSingleton().getRenderSystem());
         EGLContext* mainContext = static_cast<EGLContext*>(renderSystem->_getMainContext());
         ::EGLContext shareContext = (::EGLContext) 0;
diff --git a/RenderSystems/GLSupport/src/EGL/OgreEGLWindow.cpp b/RenderSystems/GLSupport/src/EGL/OgreEGLWindow.cpp
index 0c5d9323e..209508bf9 100644
--- a/RenderSystems/GLSupport/src/EGL/OgreEGLWindow.cpp
+++ b/RenderSystems/GLSupport/src/EGL/OgreEGLWindow.cpp
@@ -215,7 +215,7 @@ namespace Ogre {
 #if OGRE_PLATFORM == OGRE_PLATFORM_EMSCRIPTEN
         int* gamma_attribs = NULL;
 #else
-        int gamma_attribs[] = {EGL_GL_COLORSPACE_KHR, EGL_GL_COLORSPACE_SRGB_KHR, EGL_NONE};
+        int gamma_attribs[] = {EGL_NONE};
 #endif
         mHwGamma = mHwGamma && mGLSupport->checkExtension("EGL_KHR_gl_colorspace");
 
diff --git a/RenderSystems/GLSupport/src/GLSL/OgreGLSLShaderCommon.cpp b/RenderSystems/GLSupport/src/GLSL/OgreGLSLShaderCommon.cpp
index e4988cfe7..07002d06b 100644
--- a/RenderSystems/GLSupport/src/GLSL/OgreGLSLShaderCommon.cpp
+++ b/RenderSystems/GLSupport/src/GLSL/OgreGLSLShaderCommon.cpp
@@ -61,11 +61,11 @@ namespace Ogre {
 
         // Preprocess the GLSL shader in order to get a clean source
         CPreprocessor cpp;
-
+        if (getLanguage() == "glsles" && mSource.find("#version") == String::npos) mSource = String("#version 300 es\n#define __VERSION__ 300\n") + mSource;
         // Define "predefined" macros.
         if(getLanguage() == "glsles")
             cpp.Define("GL_ES", 5, "1", 1);
-
+        if (getLanguage() == "glsl" && mSource.find("#version") == String::npos) mSource = String("#version 330 core\n#define __VERSION__ 330\n") + mSource;
         size_t versionPos = mSource.find("#version");
         if(versionPos != String::npos)
         {
diff --git a/RenderSystems/GLSupport/src/OSX/OgreOSXCocoaWindow.mm b/RenderSystems/GLSupport/src/OSX/OgreOSXCocoaWindow.mm
index 85d62c04e..bad25d424 100644
--- a/RenderSystems/GLSupport/src/OSX/OgreOSXCocoaWindow.mm
+++ b/RenderSystems/GLSupport/src/OSX/OgreOSXCocoaWindow.mm
@@ -406,8 +406,8 @@ namespace Ogre {
     unsigned int CocoaWindow::getWidth() const
     {
         // keep mWidth in sync with reality
-        OgreAssertDbg(mView == nil || int(mWidth) == _getPixelFromPoint([mView frame].size.width),
-                      "Window dimension mismatch. Did you call windowMovedOrResized?");
+        //OgreAssertDbg(mView == nil || int(mWidth) == _getPixelFromPoint([mView frame].size.width),
+                      //"Window dimension mismatch. Did you call windowMovedOrResized?");
 
         return mWidth;
     }
@@ -415,8 +415,8 @@ namespace Ogre {
     unsigned int CocoaWindow::getHeight() const
     {
         // keep mHeight in sync with reality
-        OgreAssertDbg(mView == nil || int(mHeight) == _getPixelFromPoint([mView frame].size.height),
-                      "Window dimension mismatch. Did you call windowMovedOrResized?");
+        //OgreAssertDbg(mView == nil || int(mHeight) == _getPixelFromPoint([mView frame].size.height),
+                      //"Window dimension mismatch. Did you call windowMovedOrResized?");
 
         return mHeight;
     }
