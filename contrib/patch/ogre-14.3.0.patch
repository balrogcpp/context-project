diff --git a/CMake/Templates/imconfig.h b/CMake/Templates/imconfig.h
index 7f6a28ce2..861009898 100644
--- a/CMake/Templates/imconfig.h
+++ b/CMake/Templates/imconfig.h
@@ -1,5 +1,6 @@
 #pragma once
 #define IMGUI_DISABLE_OBSOLETE_FUNCTIONS
+#define IMGUI_USE_WCHAR32
 #include <OgreOverlayPrerequisites.h>
 #define IMGUI_API _OgreOverlayExport
 #cmakedefine IMGUI_ENABLE_FREETYPE
\ No newline at end of file
diff --git a/CMakeLists.txt b/CMakeLists.txt
index ade278ef3..ff97eb496 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -14,7 +14,7 @@
 # and provide build configuration options.
 ######################################################################
 
-cmake_minimum_required(VERSION 3.13.0)
+cmake_minimum_required(VERSION 3.15.0)
 
 set(CMAKE_CXX_STANDARD 14)
 set(CMAKE_CXX_STANDARD_REQUIRED ON)
@@ -260,12 +260,12 @@ elseif(EMSCRIPTEN)
   set(OGRE_BUILD_PLUGIN_BSP FALSE CACHE BOOL "Disable pcz on Emscripten" FORCE)
   set(OGRE_BUILD_TOOLS FALSE CACHE BOOL "Disable tools on Emscripten" FORCE)
   set(OGRE_BUILD_TESTS FALSE CACHE BOOL "Disable tests on Emscripten" FORCE)
-  set(OGRE_BUILD_COMPONENT_VOLUME FALSE CACHE BOOL "Disable volume component on Emscripten" FORCE)
+  #set(OGRE_BUILD_COMPONENT_VOLUME FALSE CACHE BOOL "Disable volume component on Emscripten" FORCE)
   set(OGRE_BUILD_COMPONENT_PAGING FALSE CACHE BOOL "Disable paging component on Emscripten" FORCE)
-  set(OGRE_BUILD_COMPONENT_TERRAIN FALSE CACHE BOOL "Disable terrain component on Emscripten" FORCE)
+  #set(OGRE_BUILD_COMPONENT_TERRAIN FALSE CACHE BOOL "Disable terrain component on Emscripten" FORCE)
   set(OGRE_STATIC TRUE CACHE BOOL "Forcing static build for Emscripten" FORCE)
 
-  set(OGRE_CONFIG_THREADS "0" CACHE STRING "Threading is unstable on Emscripten" FORCE)
+  #set(OGRE_CONFIG_THREADS "0" CACHE STRING "Threading is unstable on Emscripten" FORCE)
 elseif (APPLE AND NOT APPLE_IOS)
   # Make sure that the GLES2 render system is disabled for non-iOS Apple builds
   set(OGRE_BUILD_RENDERSYSTEM_GLES2 FALSE CACHE BOOL "" FORCE)
@@ -373,7 +373,7 @@ cmake_dependent_option(OGRE_INSTALL_SAMPLES "Install Ogre demos." TRUE "OGRE_BUI
 option(OGRE_INSTALL_TOOLS "Install Ogre tools." TRUE)
 option(OGRE_INSTALL_DOCS "Install documentation." TRUE)
 cmake_dependent_option(OGRE_INSTALL_PDB "Install debug pdb files" TRUE "MSVC" FALSE)
-option(OGRE_PROFILING "Enable internal instrumentation." FALSE)
+cmake_dependent_option(OGRE_PROFILING "Enable internal instrumentation." TRUE "${CMAKE_BUILD_TYPE} MATCHES Debug OR ${CMAKE_BUILD_TYPE} MATCHES RelWithDebInfo" FALSE)
 set(OGRE_PROFILING_REMOTERY_PATH "" CACHE PATH "set this to Remotery/lib to use Remotery instead of the buildin profiler")
 cmake_dependent_option(OGRE_CONFIG_STATIC_LINK_CRT "Statically link the MS CRT dlls (msvcrt)" FALSE "MSVC" FALSE)
 set(OGRE_LIB_DIRECTORY "lib${LIB_SUFFIX}" CACHE STRING "Install path for libraries, e.g. 'lib64' on some 64-bit Linux distros.")
diff --git a/Components/Overlay/CMakeLists.txt b/Components/Overlay/CMakeLists.txt
index 41bd63464..a419aa21b 100644
--- a/Components/Overlay/CMakeLists.txt
+++ b/Components/Overlay/CMakeLists.txt
@@ -92,7 +92,7 @@ if(OGRE_BUILD_COMPONENT_OVERLAY_IMGUI)
   configure_file(${OGRE_TEMPLATES_DIR}/imconfig.h ${IMGUI_DIR}/imconfig.h)
 
   list(APPEND HEADER_FILES
-    ${IMGUI_DIR}/imgui.h
+    ${IMGUI_DIR}/imgui.h ${IMGUI_DIR}/imgui_internal.h ${IMGUI_DIR}/imstb_textedit.h ${IMGUI_DIR}/imstb_truetype.h ${IMGUI_DIR}/imstb_rectpack.h
     ${IMGUI_DIR}/imconfig.h)
 endif()
 
diff --git a/Components/Overlay/src/OgreOverlayProfileSessionListener.cpp b/Components/Overlay/src/OgreOverlayProfileSessionListener.cpp
index 81b94a456..9e2e070db 100644
--- a/Components/Overlay/src/OgreOverlayProfileSessionListener.cpp
+++ b/Components/Overlay/src/OgreOverlayProfileSessionListener.cpp
@@ -108,7 +108,7 @@ namespace Ogre
     void OverlayProfileSessionListener::finializeSession()
     {
         OverlayContainer* container = dynamic_cast<OverlayContainer*>(mProfileGui);
-        if (container)
+        if (0)
         {
             while (!container->getChildren().empty())
             {
@@ -121,7 +121,7 @@ namespace Ogre
             OverlayManager::getSingleton().destroyOverlayElement(mProfileGui);
         if(mOverlay)
             OverlayManager::getSingleton().destroy(mOverlay);
-
+        OverlayManager::getSingleton().destroyAllOverlayElements();
         mProfileBars.clear();
     }
     //-----------------------------------------------------------------------
diff --git a/Components/Terrain/include/OgreTerrainQuadTreeNode.h b/Components/Terrain/include/OgreTerrainQuadTreeNode.h
index e2e18a155..1a2146106 100644
--- a/Components/Terrain/include/OgreTerrainQuadTreeNode.h
+++ b/Components/Terrain/include/OgreTerrainQuadTreeNode.h
@@ -77,7 +77,7 @@ namespace Ogre
         the same (relative) LOD index no matter where you are in the tree, therefore
         buffers can potentially be reused more easily.
     */
-    class _OgreTerrainExport TerrainQuadTreeNode : private Renderable, private MovableObject
+    class _OgreTerrainExport TerrainQuadTreeNode : public Renderable, public MovableObject
     {
     public:
         /** Constructor.
diff --git a/Components/Terrain/src/OgreTerrain.cpp b/Components/Terrain/src/OgreTerrain.cpp
index e0d5d7716..1650982ba 100644
--- a/Components/Terrain/src/OgreTerrain.cpp
+++ b/Components/Terrain/src/OgreTerrain.cpp
@@ -4134,7 +4134,7 @@ namespace Ogre
         else
         {
             // float3 position
-            sz += sizeof(float) * 3;
+            sz += sizeof(float) * 3; if(0) sz += sizeof(float) * 6; // + normal + tangent
             // float2 uv
             sz += sizeof(float) * 2;
         }
diff --git a/Components/Terrain/src/OgreTerrainQuadTreeNode.cpp b/Components/Terrain/src/OgreTerrainQuadTreeNode.cpp
index 458419bc5..3c7bb1405 100644
--- a/Components/Terrain/src/OgreTerrainQuadTreeNode.cpp
+++ b/Components/Terrain/src/OgreTerrainQuadTreeNode.cpp
@@ -178,7 +178,7 @@ namespace Ogre
             for (int i = 0; i < 4; ++i)
                 mChildren[i]->prepare();
         }
-
+        setCastShadows(TerrainGlobalOptions::getSingleton().getCastsDynamicShadows());
     }
     //---------------------------------------------------------------------
     void TerrainQuadTreeNode::prepare(StreamSerialiser& stream)
@@ -587,7 +587,7 @@ namespace Ogre
                 // 28 bytes per vertex, compatibility
                 // POSITION
                 // float3(x, y, z)
-                offset += dcl->addElement(POSITION_BUFFER, offset, VET_FLOAT3, VES_POSITION).getSize();
+                offset += dcl->addElement(POSITION_BUFFER, offset, VET_FLOAT3, VES_POSITION).getSize(); if(0){offset += dcl->addElement(POSITION_BUFFER, offset, VET_FLOAT3, VES_NORMAL).getSize(); offset += dcl->addElement(POSITION_BUFFER, offset, VET_FLOAT3, VES_TANGENT).getSize();}
                 // UV0
                 // float2(u, v)
                 dcl->addElement(POSITION_BUFFER, offset, VET_FLOAT2, VES_TEXTURE_COORDINATES, 0).getSize();
@@ -893,7 +893,7 @@ namespace Ogre
             *pPosBuf++ = pos.x;
             *pPosBuf++ = pos.y;
             *pPosBuf++ = pos.z;
-
+            if(0){Vector3 n = Vector3::ZERO, t, c, adj[8]; mTerrain->getPointFromSelfOrNeighbour(x, y ,&c); mTerrain->getPointFromSelfOrNeighbour(x+1, y, &adj[0]); mTerrain->getPointFromSelfOrNeighbour(x+1, y+1, &adj[1]); mTerrain->getPointFromSelfOrNeighbour(x, y+1, &adj[2]); mTerrain->getPointFromSelfOrNeighbour(x-1, y+1, &adj[3]); mTerrain->getPointFromSelfOrNeighbour(x-1, y, &adj[4]); mTerrain->getPointFromSelfOrNeighbour(x-1, y-1, &adj[5]); mTerrain->getPointFromSelfOrNeighbour(x, y-1, &adj[6]); mTerrain->getPointFromSelfOrNeighbour(x+1, y-1, &adj[7]); for (int i = 0; i < 8; ++i) n += Math::calculateBasicFaceNormal(c, adj[i], adj[(i+1)%8]); n.normalise(); *pPosBuf++ = n.x; *pPosBuf++ = n.y; *pPosBuf++ = n.z; t = adj[4].x >= 0.0 ? adj[4] - c : c - adj[0]; t.normalise(); *pPosBuf++ = t.x; *pPosBuf++ = t.y; *pPosBuf++ = t.z;}
             // UVs - base UVs vary from 0 to 1, all other values
             // will be derived using scalings
             *pPosBuf++ = x * uvScale;
diff --git a/OgreMain/CMakeLists.txt b/OgreMain/CMakeLists.txt
index 483f9f3dd..0b87d5d66 100644
--- a/OgreMain/CMakeLists.txt
+++ b/OgreMain/CMakeLists.txt
@@ -216,10 +216,10 @@ if (APPLE)
   endif()
 endif ()
 target_link_libraries(OgreMain PUBLIC ${PLATFORM_LIBS} PRIVATE ${LIBRARIES} ${CMAKE_DL_LIBS})
-
+if (!APPLE)
 # specify a precompiled header to use
 add_native_precompiled_header(OgreMain "$<$<COMPILE_LANGUAGE:CXX>:${CMAKE_CURRENT_SOURCE_DIR}/src/OgreStableHeaders.h>")
-
+endif ()
 # install OgreMain
 ogre_config_lib(OgreMain TRUE)
 install(FILES ${HEADER_FILES}
diff --git a/OgreMain/include/OgreException.h b/OgreMain/include/OgreException.h
index ef6be0b05..edf200539 100644
--- a/OgreMain/include/OgreException.h
+++ b/OgreMain/include/OgreException.h
@@ -69,7 +69,7 @@ THE SOFTWARE.
 /// replaced with OgreAssert(expr, mesg) in Debug configuration
 #   define OgreAssertDbg( expr, mesg )
 #endif
-
+#define OgreAssertDbg2( a ) OgreAssertDbg( a, #a )
 namespace Ogre {
 
     /** \addtogroup Core
@@ -272,12 +272,18 @@ namespace Ogre {
             }
         }
     public:
+#if defined(_MSC_VER) && defined(_DEBUG)
         static OGRE_NORETURN void throwException(
+#else
+        static void throwException(
+#endif
             Exception::ExceptionCodes code,
             const String& desc,
             const String& src, const char* file, long line)
         {
+#if OGRE_ASSERT_MODE == 2 || (OGRE_ASSERT_MODE == 1 && !defined(OGRE_DEBUG_MODE))
             _throwException(code, code, desc, src, file, line);
+#endif
         }
     };
     
diff --git a/OgreMain/src/OgreRoot.cpp b/OgreMain/src/OgreRoot.cpp
index 7100c333e..11c636e9a 100644
--- a/OgreMain/src/OgreRoot.cpp
+++ b/OgreMain/src/OgreRoot.cpp
@@ -911,7 +911,7 @@ namespace Ogre {
     //-----------------------------------------------------------------------
     void Root::unloadPlugins(void)
     {
-#if OGRE_PLATFORM != OGRE_PLATFORM_EMSCRIPTEN
+#ifndef OGRE_STATIC_LIB
         // unload dynamic libs first
         for (PluginLibList::reverse_iterator i = mPluginLibs.rbegin(); i != mPluginLibs.rend(); ++i)
         {
@@ -1071,7 +1071,7 @@ namespace Ogre {
     //-----------------------------------------------------------------------
     void Root::loadPlugin(const String& pluginName)
     {
-#if OGRE_PLATFORM != OGRE_PLATFORM_EMSCRIPTEN
+#ifndef OGRE_STATIC_LIB
         // Load plugin library
         DynLib* lib = DynLibManager::getSingleton().load( pluginName );
         // Store for later unload
@@ -1098,7 +1098,7 @@ namespace Ogre {
     //-----------------------------------------------------------------------
     void Root::unloadPlugin(const String& pluginName)
     {
-#if OGRE_PLATFORM != OGRE_PLATFORM_EMSCRIPTEN
+#ifndef OGRE_STATIC_LIB
         PluginLibList::iterator i;
 
         for (i = mPluginLibs.begin(); i != mPluginLibs.end(); ++i)
diff --git a/OgreMain/src/OgreShadowCameraSetupFocused.cpp b/OgreMain/src/OgreShadowCameraSetupFocused.cpp
index 9a76f0291..b414a42fc 100644
--- a/OgreMain/src/OgreShadowCameraSetupFocused.cpp
+++ b/OgreMain/src/OgreShadowCameraSetupFocused.cpp
@@ -106,6 +106,16 @@ namespace Ogre
         {
             // For directional lights, all we care about is projecting the receivers
             // backwards towards the light, clipped by the camera region
+            if (float dot = cam.getDerivedDirection().dotProduct(light.getDerivedDirection()) > 0.0 && false) {
+                mBodyB.extend(-light.getDerivedDirection()*0.5*cam.getFarClipDistance());
+                mBodyB.extend(-light.getDerivedDirection().crossProduct(Vector3::UNIT_X)*0.5*cam.getFarClipDistance());
+                mBodyB.extend(-light.getDerivedDirection().crossProduct(Vector3::UNIT_Y)*0.5*cam.getFarClipDistance());
+                mBodyB.extend(-light.getDerivedDirection().crossProduct(Vector3::UNIT_Z)*0.5*cam.getFarClipDistance());
+                mBodyB.extend(light.getDerivedDirection()*0.5*cam.getFarClipDistance());
+                mBodyB.extend(light.getDerivedDirection().crossProduct(Vector3::UNIT_X)*0.5*cam.getFarClipDistance());
+                mBodyB.extend(light.getDerivedDirection().crossProduct(Vector3::UNIT_Y)*0.5*cam.getFarClipDistance());
+                mBodyB.extend(light.getDerivedDirection().crossProduct(Vector3::UNIT_Z)*0.5*cam.getFarClipDistance());
+            }
             mBodyB.clip(receiverBB.intersection(sceneBB));
 
             // Also clip based on shadow far distance if appropriate
diff --git a/OgreMain/src/OgreShadowCameraSetupPSSM.cpp b/OgreMain/src/OgreShadowCameraSetupPSSM.cpp
index 560ac60b0..539c2e820 100644
--- a/OgreMain/src/OgreShadowCameraSetupPSSM.cpp
+++ b/OgreMain/src/OgreShadowCameraSetupPSSM.cpp
@@ -50,9 +50,9 @@ namespace Ogre
     //---------------------------------------------------------------------
     void PSSMShadowCameraSetup::calculateSplitPoints(uint splitCount, Real nearDist, Real farDist, Real lambda)
     {
-        if (splitCount < 2)
-            OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, "Cannot specify less than 2 splits", 
-            "PSSMShadowCameraSetup::calculateSplitPoints");
+        //if (splitCount < 2)
+            //OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, "Cannot specify less than 2 splits",
+            //"PSSMShadowCameraSetup::calculateSplitPoints");
 
         mSplitPoints.resize(splitCount + 1);
         mOptimalAdjustFactors.resize(splitCount);
diff --git a/OgreMain/src/OgreShadowRenderer.cpp b/OgreMain/src/OgreShadowRenderer.cpp
index 3b320f711..69edddd74 100644
--- a/OgreMain/src/OgreShadowRenderer.cpp
+++ b/OgreMain/src/OgreShadowRenderer.cpp
@@ -757,7 +757,7 @@ void SceneManager::ShadowRenderer::prepareShadowTextures(Camera* cam, Viewport*
     else
     {
         // disable fogging explicitly
-        mShadowReceiverPass->setFog(true, FOG_NONE);
+        //mShadowReceiverPass->setFog(true, FOG_NONE);
     }
 
     // Iterate over the lights we've found, max out at the limit of light textures
@@ -1297,7 +1297,7 @@ void SceneManager::ShadowRenderer::initShadowVolumeMaterials()
      */
     OgreAssert( mDestRenderSystem, "no RenderSystem");
 
-    if (mShadowMaterialInitDone)
+    if (mShadowMaterialInitDone = true)
         return;
 
     if (!mShadowDebugPass)
diff --git a/PlugIns/STBICodec/CMakeLists.txt b/PlugIns/STBICodec/CMakeLists.txt
index 10283f51e..8cb4ec14b 100644
--- a/PlugIns/STBICodec/CMakeLists.txt
+++ b/PlugIns/STBICodec/CMakeLists.txt
@@ -28,7 +28,7 @@ if(CMAKE_COMPILER_IS_GNUCXX)
   target_link_libraries(Codec_STBI PRIVATE gcc)
 endif()
 
-if(ZLIB_FOUND)
+if(0)
   target_compile_definitions(Codec_STBI PRIVATE HAVE_ZLIB)
   target_link_libraries(Codec_STBI PRIVATE ZLIB::ZLIB)
 endif()
diff --git a/PlugIns/STBICodec/src/OgreSTBICodec.cpp b/PlugIns/STBICodec/src/OgreSTBICodec.cpp
index f89e9a16c..eec4a06c8 100644
--- a/PlugIns/STBICodec/src/OgreSTBICodec.cpp
+++ b/PlugIns/STBICodec/src/OgreSTBICodec.cpp
@@ -41,7 +41,7 @@ THE SOFTWARE.
 #define STB_IMAGE_IMPLEMENTATION
 #define STB_IMAGE_STATIC
 #include "stbi/stb_image.h"
-
+#undef HAVE_ZLIB
 #ifdef HAVE_ZLIB
 #include <zlib.h>
 static Ogre::uchar* custom_zlib_compress(Ogre::uchar* data, int data_len, int* out_len, int /*quality*/)
diff --git a/RenderSystems/GL3Plus/src/OgreGL3PlusPixelFormat.cpp b/RenderSystems/GL3Plus/src/OgreGL3PlusPixelFormat.cpp
index f1f6c5d1e..415c92f36 100644
--- a/RenderSystems/GL3Plus/src/OgreGL3PlusPixelFormat.cpp
+++ b/RenderSystems/GL3Plus/src/OgreGL3PlusPixelFormat.cpp
@@ -180,7 +180,7 @@ namespace Ogre  {
             {GL_NONE, GL_NONE, GL_COMPRESSED_RGBA_ASTC_12x12_KHR},// PF_ASTC_RGBA_12X12_LDR
             {GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, GL_DEPTH_COMPONENT32}, // PF_DEPTH32
             {GL_DEPTH_COMPONENT, GL_FLOAT, GL_DEPTH_COMPONENT32F}, // PF_DEPTH32F
-            {GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, GL_DEPTH24_STENCIL8}, // PF_DEPTH24_STENCIL8
+            {GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, GL_DEPTH_COMPONENT24}, // PF_DEPTH24_STENCIL8
     };
 
     GLenum GL3PlusPixelUtil::getGLOriginFormat(PixelFormat pf)
diff --git a/RenderSystems/GLES2/src/GLSLES/src/OgreGLSLESLinkProgram.cpp b/RenderSystems/GLES2/src/GLSLES/src/OgreGLSLESLinkProgram.cpp
index 5cb052037..4d5a1e514 100644
--- a/RenderSystems/GLES2/src/GLSLES/src/OgreGLSLESLinkProgram.cpp
+++ b/RenderSystems/GLES2/src/GLSLES/src/OgreGLSLESLinkProgram.cpp
@@ -199,7 +199,7 @@ namespace Ogre {
                     GLsizei glArraySize = (GLsizei)def->arraySize;
 
                     // this is a monolitic program so we can use the cache of any attached shader
-                    GLUniformCache* uniformCache =  mShaders[GPT_VERTEX_PROGRAM]->getUniformCache();
+                    GLUniformCache* uniformCache =  mShaders[GPT_FRAGMENT_PROGRAM]->getUniformCache();
                     void* val = def->isSampler() ? (void*)params->getRegPointer(def->physicalIndex)
                                                  : (void*)params->getFloatPointer(def->physicalIndex);
 
diff --git a/RenderSystems/GLES2/src/OgreGLES2HardwarePixelBuffer.cpp b/RenderSystems/GLES2/src/OgreGLES2HardwarePixelBuffer.cpp
index 2b1a1f556..a4c498b75 100644
--- a/RenderSystems/GLES2/src/OgreGLES2HardwarePixelBuffer.cpp
+++ b/RenderSystems/GLES2/src/OgreGLES2HardwarePixelBuffer.cpp
@@ -122,7 +122,7 @@ namespace Ogre {
           mLevel(level)
     {
         // Get face identifier
-        mFaceTarget = mTarget;
+        mFaceTarget = mTarget; mUsage &= ~TU_AUTOMIPMAP;
         if(mTarget == GL_TEXTURE_CUBE_MAP)
             mFaceTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + face;
 
diff --git a/RenderSystems/GLES2/src/OgreGLES2PixelFormat.cpp b/RenderSystems/GLES2/src/OgreGLES2PixelFormat.cpp
index 7e1578e23..09b354923 100644
--- a/RenderSystems/GLES2/src/OgreGLES2PixelFormat.cpp
+++ b/RenderSystems/GLES2/src/OgreGLES2PixelFormat.cpp
@@ -265,9 +265,9 @@ namespace Ogre {
             {GL_NONE, GL_NONE, GL_COMPRESSED_RGBA_ASTC_10x10_KHR},// PF_ASTC_RGBA_10X10_LDR
             {GL_NONE, GL_NONE, GL_COMPRESSED_RGBA_ASTC_12x10_KHR},// PF_ASTC_RGBA_12X10_LDR
             {GL_NONE, GL_NONE, GL_COMPRESSED_RGBA_ASTC_12x12_KHR},// PF_ASTC_RGBA_12X12_LDR
-            {GL_NONE, GL_NONE, GL_NONE}, // PF_DEPTH32
+            {GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, GL_DEPTH_COMPONENT32_OES}, // PF_DEPTH32
             {GL_NONE, GL_NONE, GL_NONE}, // PF_DEPTH32F
-            {GL_NONE, GL_NONE, GL_NONE}, // PF_DEPTH24_STENCIL8
+            {GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, GL_DEPTH_COMPONENT24_OES}, // PF_DEPTH24_STENCIL8
     };
 
     void GLES2PixelUtil::useSizedFormats()
diff --git a/RenderSystems/GLSupport/src/EGL/Android/OgreAndroidEGLWindow.cpp b/RenderSystems/GLSupport/src/EGL/Android/OgreAndroidEGLWindow.cpp
index 353497efb..04d5ffc71 100644
--- a/RenderSystems/GLSupport/src/EGL/Android/OgreAndroidEGLWindow.cpp
+++ b/RenderSystems/GLSupport/src/EGL/Android/OgreAndroidEGLWindow.cpp
@@ -120,6 +120,7 @@ namespace Ogre {
                                 "EGLWindow::create");
                 }
 
+                mEglSurface = eglGetCurrentSurface(EGL_DRAW);
                 mEglDisplay = eglGetCurrentDisplay();
             }
 
diff --git a/RenderSystems/GLSupport/src/EGL/OgreEGLContext.cpp b/RenderSystems/GLSupport/src/EGL/OgreEGLContext.cpp
index 9277d4eb1..1778d4ed8 100644
--- a/RenderSystems/GLSupport/src/EGL/OgreEGLContext.cpp
+++ b/RenderSystems/GLSupport/src/EGL/OgreEGLContext.cpp
@@ -49,7 +49,7 @@ namespace Ogre {
           mContext(0),
           mExternalContext(false)
     {
-        assert(drawable);
+        //assert(drawable);
         GLRenderSystemCommon* renderSystem = static_cast<GLRenderSystemCommon*>(Root::getSingleton().getRenderSystem());
         EGLContext* mainContext = static_cast<EGLContext*>(renderSystem->_getMainContext());
         ::EGLContext shareContext = (::EGLContext) 0;
diff --git a/RenderSystems/GLSupport/src/EGL/OgreEGLWindow.cpp b/RenderSystems/GLSupport/src/EGL/OgreEGLWindow.cpp
index 0c5d9323e..209508bf9 100644
--- a/RenderSystems/GLSupport/src/EGL/OgreEGLWindow.cpp
+++ b/RenderSystems/GLSupport/src/EGL/OgreEGLWindow.cpp
@@ -215,7 +215,7 @@ namespace Ogre {
 #if OGRE_PLATFORM == OGRE_PLATFORM_EMSCRIPTEN
         int* gamma_attribs = NULL;
 #else
-        int gamma_attribs[] = {EGL_GL_COLORSPACE_KHR, EGL_GL_COLORSPACE_SRGB_KHR, EGL_NONE};
+        int gamma_attribs[] = {EGL_NONE};
 #endif
         mHwGamma = mHwGamma && mGLSupport->checkExtension("EGL_KHR_gl_colorspace");
 
diff --git a/RenderSystems/GLSupport/src/GLSL/OgreGLSLShaderCommon.cpp b/RenderSystems/GLSupport/src/GLSL/OgreGLSLShaderCommon.cpp
index 436c498a4..45cab5177 100644
--- a/RenderSystems/GLSupport/src/GLSL/OgreGLSLShaderCommon.cpp
+++ b/RenderSystems/GLSupport/src/GLSL/OgreGLSLShaderCommon.cpp
@@ -83,8 +83,8 @@ namespace Ogre {
             mSource.replace(
                 versionPos, 34,
                 StringUtil::format("#version %d%s", mShaderVersion, (isGLES && mShaderVersion > 100) ? " es" : ""));
-        }
-
+        } else { mShaderVersion = renderSystem ? renderSystem->getNativeShadingLanguageVersion() : 120; // should check, if there is free space for replace, but for it is chip and dirty
+            mSource.replace(0, 18,StringUtil::format("#version %d%s\n//", mShaderVersion, (isGLES && mShaderVersion > 100) ? " es" : (mShaderVersion > 300 ? " core" : ""))); }
         String verStr = std::to_string(mShaderVersion);
 
 #if OGRE_PLATFORM == OGRE_PLATFORM_APPLE
diff --git a/RenderSystems/GLSupport/src/OSX/OgreOSXCocoaWindow.mm b/RenderSystems/GLSupport/src/OSX/OgreOSXCocoaWindow.mm
index 269a2a177..9a3f9a4e6 100644
--- a/RenderSystems/GLSupport/src/OSX/OgreOSXCocoaWindow.mm
+++ b/RenderSystems/GLSupport/src/OSX/OgreOSXCocoaWindow.mm
@@ -410,8 +410,8 @@ namespace Ogre {
     unsigned int CocoaWindow::getWidth() const
     {
         // keep mWidth in sync with reality
-        OgreAssertDbg(mView == nil || int(mWidth) == _getPixelFromPoint([mView frame].size.width),
-                      "Window dimension mismatch. Did you call windowMovedOrResized?");
+        //OgreAssertDbg(mView == nil || int(mWidth) == _getPixelFromPoint([mView frame].size.width),
+                      //"Window dimension mismatch. Did you call windowMovedOrResized?");
 
         return mWidth;
     }
@@ -419,8 +419,8 @@ namespace Ogre {
     unsigned int CocoaWindow::getHeight() const
     {
         // keep mHeight in sync with reality
-        OgreAssertDbg(mView == nil || int(mHeight) == _getPixelFromPoint([mView frame].size.height),
-                      "Window dimension mismatch. Did you call windowMovedOrResized?");
+        //OgreAssertDbg(mView == nil || int(mHeight) == _getPixelFromPoint([mView frame].size.height),
+                      //"Window dimension mismatch. Did you call windowMovedOrResized?");
 
         return mHeight;
     }
